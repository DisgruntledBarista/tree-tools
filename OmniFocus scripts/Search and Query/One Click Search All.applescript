--Ver 1.1-- ONE CLICK SEARCH ALL-- Scripts launched from Toolbar can not use System Events to Make toolbar visible or enable toolbar icon mode-- so we just use a dialog box to get the string-- First makes everything visible and selects the Library and Inbox, then offers a search dialog, with most recent-- Ver 0.6  --		Creates a new window on each run (can be disabled)-- Ver 0.7 --		Corrected automatic clearing of filters-- Ver 0.8 --		Search string can be passed as a parameter from LAUNCHBAR http://bit.ly/LBPram-- 			--		Default scope can be reset to ALL by changing pblnDefaultRemaining property (below) to false-- Ver 0.9 --		Switches for New Window --nw or Existing window --ew (to override the default set in pblnNewWin - below)-- Ver 1.0 --		Scope switches for Remaining --r or All --a  (override the default set in pblnDefaultRemaining - below)-- Ver 1.1			Two edits suggested by WhPalmer4 to avoid "oWin" bugproperty pTitle : "One-Click Search All - Ver 1.1"property pblnNewWin : trueproperty pblnDefaultRemaining : true--property pvarPerspective : missing valueproperty pstrDefaultViewMode : "project"property plstDefaultFocus : {}property plstDefaultFilters : {"remaining", "none", "none", "incomplete", "all", "any"}property pAll : "Search ALL"property pRemaining : "Search REMAINING"-- SWITCHES for LAUNCHBAR parameter strings and applescript dialog text field-- 1. SEARCH SCOPE: determined by pblnDefaultRemaining above but can be overridden by adding a switch--		after the search string:    --a (for ALL)  or --r (for REMAINING)--		(note that this overrides the All/Remaining button choice in the Applescript dialog)-- 2. WINDOW: The default for whether the search is shown in a new window (pblnNewWin above) can be--		overridden by --nw  (for New Window) or --ew (for Existing Window)-- 3. Window & search scope switches can be combined, but must be separated by a space --		--  e.g.   <search string> --a nw  OR <search string> --ew r  on handle_string(strTerm)	if pblnDefaultRemaining then		set strScope to pRemaining	else		set strScope to pAll	end if		set blnNewWin to pblnNewWin		set text item delimiters to "--"	set lstParts to text items of strTerm	set text item delimiters to space	set blnSwitch to false	if length of lstParts = 2 then		set lstSwitches to text items of item 2 of lstParts		if "a" is in lstSwitches then			set strScope to pAll			set blnSwitch to true		else if "r" is in lstSwitches then			set strScope to pRemaining			set blnSwitch to true		end if		if "nw" is in lstSwitches then			set blnNewWin to true			set blnSwitch to true		else if "ew" is in lstSwitches then			set blnNewWin to false			set blnSwitch to true		end if	end if		-- failing a switch, set the search scope from the value of the default property (above)	if blnSwitch then set strTerm to Trim(first item of lstParts)	tell application id "com.omnigroup.omnifocus"		activate		set oDoc to front document		my FindTerm(oDoc, blnNewWin, strTerm, strScope)	end tellend handle_stringon run {}	tell application id "com.omnigroup.omnifocus"		-- GET A REFERENCE TO THE FRONT OMNIFOCUS WINDOW & ITS DOCUMENT		set oDoc to default document		if (count of document windows of oDoc) < 1 then			tell oDoc				set oWin to make new document window			end tell		else			set oWin to front document window of oDoc		end if		if oWin is missing value then set oWin to front document window of oDoc		set visible of oWin to true				-- TRY TO READ AND CLEAR THE EXISTING SEARCH TERM		tell oWin			set blnSearchBar to false			repeat with iTick from 1 to 5				try					set strTerm to search term					set blnSearchBar to true				end try				if blnSearchBar then					if not pblnNewWin then set search term to ""					exit repeat				else					delay 0.2				end if			end repeat						-- WARN & EXIT IF THE SEARCH BAR IS INVISIBLE			if not blnSearchBar then				display dialog "Use View > Customize Toolbar to drag search bar onto toolbar" buttons {"OK"} default button "OK" with title pTitle				return			end if						-- GET A SEARCH STRING (AND THE DESIRED SCOPE OF THE SEARCH)			if pblnDefaultRemaining then				set lstButtons to {"Esc", pAll, pRemaining}				set strDefault to pRemaining			else				set lstButtons to {"Esc", pRemaining, pAll}				set strDefault to pAll			end if			try				set varResponse to display dialog "Search:" default answer strTerm buttons lstButtons cancel button "Esc" default button strDefault with title pTitle			on error				return			end try						if varResponse is not false then				set strTerm to text returned of varResponse				if strTerm is not "" then					set strScope to button returned of varResponse					set blnDefaultRemaining to strScope is pRemaining					if blnDefaultRemaining is not pblnDefaultRemaining then						if blnDefaultRemaining then							set strSwitch to "r"						else							set strSwitch to "a"						end if						if strTerm contains "--" then							strTerm to strTerm & space & strSwitch						else							set strTerm to strTerm & "--" & strSwitch						end if					end if					my handle_string(strTerm)				end if			end if		end tell	end tellend runon FindTerm(oDoc, blnNewWin, strTerm, strScope)	tell application id "com.omnigroup.omnifocus"		-- Either Clear the current window for a full search, or create and clear a new window		if blnNewWin then			tell oDoc				set winSearch to make new document window			end tell		else			set winSearch to front document window of oDoc			if visible of winSearch is false then				set visible of winSearch to true				set winSearch to front document window of oDoc			end if		end if		tell winSearch			if selected view mode identifier is not pstrDefaultViewMode then ¬				set its selected view mode identifier to pstrDefaultViewMode						if my IsNarrowed(focus) then set focus to {}						if strScope is pAll then				my SetFilters(winSearch, {"", "-", "-", "", "", ""}, (pstrDefaultViewMode = "context"), "")			else				my SetFilters(winSearch, {"remaining", "-", "-", "incomplete", "", ""}, (pstrDefaultViewMode = "context"), "")			end if						tell sidebar				select tree 1				select tree 2 with extending			end tell			try				set search term to strTerm			on error				display dialog "Use View > Customize Toolbar to drag search field onto toolbar, and try again." buttons {"OK"} ¬					default button "OK" with title "No search field on OmniFocus toolbar"			end try		end tell	end tellend FindTermon SetFilters(oWin, {strSmartGroup, strGrouping, strSorting, strState, strFlagged, strDurn}, blnContextView, strComment)	if blnContextView then		set strClass to "-contexts"	else		set strClass to "-projects"	end if	tell application id "com.omnigroup.omnifocus"		tell oWin			if strSmartGroup is not "" then				if strSmartGroup is not "-" then if selected smart group identifier of sidebar is not strSmartGroup then ¬					set selected smart group identifier of sidebar to strSmartGroup & strClass			else				set selected smart group identifier of sidebar to "all" & strClass			end if			tell content				try					if strGrouping is not "" then						if strGrouping is not "-" then if selected grouping identifier is not strGrouping then ¬							set selected grouping identifier to strGrouping					else						set selected grouping identifier to "none"					end if				on error					my CheckIdentifier("grouping", strGrouping, strComment)				end try								try					if strSorting is not "" then						if strSorting is not "-" then if selected sorting identifier is not strSorting then ¬							set selected sorting identifier to strSorting					else						if blnContextView then							set selected sorting identifier to "context"						else							set selected sorting identifier to "none"						end if					end if				on error					my CheckIdentifier("sorting", strSorting, strComment)				end try								try					if strState is not "" then						if strState is not "-" then if selected task state filter identifier is not strState then ¬							set selected task state filter identifier to strState					else						set selected task state filter identifier to "all"					end if				on error					my CheckIdentifier("task state filter", strState, strComment)				end try								try					if strFlagged is not "" then						if strFlagged is not "-" then if selected task flagged filter identifier is not strFlagged then ¬							set selected task flagged filter identifier to strFlagged					else						set selected task flagged filter identifier to "all"					end if				on error					my CheckIdentifier("task flagged filter", strFlagged, strComment)				end try								try					if strDurn is not "" then						if strDurn is not "-" then if selected task duration filter identifier is not strDurn then ¬							set selected task duration filter identifier to strDurn					else						set selected task duration filter identifier to "any"					end if				on error					my CheckIdentifier("task duration filter", strDurn, strComment)				end try			end tell		end tell	end tellend SetFilterson CheckIdentifier(strIdentifier, strSetting, strComments)	display dialog "Unknown " & strIdentifier & " identifier: " & return & return & quote & strSetting & quote & ¬		return & return & "Correct and try again." buttons {"OK"}end CheckIdentifieron GetFilters(oWin)	tell application "OmniFocus"		set strSmartGroup to selected smart group identifier of sidebar of oWin		set my text item delimiters to "-"		set lstParts to text items of strSmartGroup		set strSmartGroup to (items 1 thru ((length of lstParts) - 1) of lstParts) as string		set my text item delimiters to space		tell content of oWin			{strSmartGroup, ¬				selected grouping identifier, selected sorting identifier, ¬				selected task state filter identifier, selected task flagged filter identifier, ¬				selected task duration filter identifier}		end tell	end tellend GetFilterson IsNarrowed(oFocus)	repeat with oObj in oFocus		return true	end repeat	return falseend IsNarrowedon Trim(strText)	set lngChars to length of strText	if lngChars is 0 then return ""	set lstWhite to {space, tab, return, ASCII character 10, ASCII character 0}		repeat with iChar from 1 to lngChars		if character iChar of strText is not in lstWhite then exit repeat	end repeat	set strText to text iChar thru lngChars of strText		repeat with iChar from length of strText to 1 by -1		if character iChar of strText is not in lstWhite then exit repeat	end repeat	set strText to text 1 thru iChar of strText		set text item delimiters to "
"	set lstParts to text items of strText	set text item delimiters to space	lstParts as textend Trim