property pTitle : "Flexible parsing of TaskPaper dates"property pVer : "0.2"property plstTestTaskPaperDates : {"2014-07-14 14:00", "2014-07-14", "07-14", "25", "14:50", "11:59:59"}-- EXAMPLE OF USE:on run	set str to ""	set {dlm, my text item delimiters} to {my text item delimiters, " → "}	repeat with oDate in plstTestTaskPaperDates		set strDate to contents of oDate		set strQuoted to quoted form of strDate		set str to (str & {strQuoted, ParseTaskPaperDate(strDate)} as string) & linefeed & linefeed	end repeat	set my text item delimiters to dlm		set str to str & linefeed & linefeed & "Applescript function: ParseTaskPaperDate(strTPDate)"		display dialog str buttons {"OK"} default button "OK" with title pTitle & "  ver. " & pVerend runon ParseTaskPaperDate(strTPDate)	set dteBase to current date	set time of dteBase to 0	set {dlm, my text item delimiters} to {my text item delimiters, space}	-- GET THE DATE STRING, AND ANY TIME STRING	set lstParts to text items of strTPDate	set lngParts to length of lstParts	if lngParts > 1 then		set {strDate, strTime} to items 1 thru 2 of lstParts	else if lngParts > 0 then		set strDateTime to item 1 of lstParts		if strDateTime contains ":" then			set {strDate, strTime} to {"", strDateTime}		else			set {strDate, strTime} to {strDateTime, ""}		end if	else		set dteBase to missing value	end if		if dteBase is not missing value then		-- PARSE ANY DATE STRING, FILLING GAPS FROM NOW		if strDate ≠ "" then			-- TRY TO READ THE DATE AS A LIST OF INTEGERS			set my text item delimiters to "-"			set lstParts to text items of strDate			set lngParts to length of lstParts			if lngParts > 3 then set lngParts to 3			try				repeat with i from 1 to lngParts					set item i of lstParts to ((item i of lstParts) as integer)				end repeat			on error				set dteBase to missing value			end try						-- FILL ANY GAPS FROM TODAYS DATE, 			-- ASSUMING THAT YEAR AND THEN MONTH ARE THE MOST LIKELY TO BE MISSING			if dteBase is not missing value then				if lngParts > 2 then					set {lngYear, lngMonth, lngDay} to lstParts				else if lngParts > 1 then					set {lngYear, lngMonth, lngDay} to {year of dteBase, item 1 of lstParts, item 2 of lstParts}				else					set {lngYear, lngMonth, lngDay} to {year of dteBase, month of dteBase, item 1 of lstParts}				end if								-- SET DATE PROPERTIES IN A SEQUENCE WHICH AVOIDS PROBLEMS WITH SHORT MONTHS				-- AND LEAP YEARS				set day of dteBase to 1 -- temporarily				set year of dteBase to lngYear				set month of dteBase to lngMonth				set day of dteBase to lngDay				set varDate to dteBase			end if		end if				-- AND PARSE ANY TIME STRING		-- Assuming that seconds and minutes are more likely to be missing than hours		if strTime ≠ "" then			set time of dteBase to 0			set varTime to 0			set my text item delimiters to ":"			set lstParts to text items of strTime			set lngParts to length of lstParts			try				repeat with i from 1 to lngParts					set item i of lstParts to item i of lstParts as integer				end repeat			on error				set varTime to missing value			end try			if varTime is not missing value then				if lngParts > 0 then					try						set hours of dteBase to item 1 of lstParts					end try				end if				if lngParts > 1 then					try						set minutes of dteBase to item 2 of lstParts					end try				end if				if lngParts > 2 then					try						set seconds of dteBase to item 3 of lstParts					end try				end if			end if		end if	end if		set my text item delimiters to dlm	return dteBaseend ParseTaskPaperDate